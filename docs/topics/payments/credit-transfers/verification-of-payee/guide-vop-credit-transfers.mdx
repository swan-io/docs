---
title: VoP with credit transfers
---

# VoP with credit transfers

Use Verification of Payee (VoP) with credit transfers by including verification tokens in `initiateCreditTransfers`.

This guide shows how to enhance the standard [credit transfer flow](../sepa/guide-initiate-ct.mdx) with pre-verified beneficiaries.

:::warning Breaking Change
**Effective October 9, 2025:** The `beneficiaryVerification` query (Dutch IBANs only) is deprecated. Use `verifySepaBeneficiary` mutation instead for all SEPA IBANs.
:::

:::tip Prerequisites
1. You're an account member with the `canInitiatePayments` [membership permission](../../../accounts/memberships/index.mdx#permissions).
1. You've pre-verified beneficiaries using [`verifySepaBeneficiary`](./guide-verify-beneficiary.mdx).
1. You're authenticating with a [user access token](../../../../developers/using-api/authentication/index.mdx#tokens-user).
:::

## Single transfer with verification token {#single-transfer}

Include a verification token in a single credit transfer for faster processing and enhanced user experience.

1. Call the `initiateCreditTransfers` mutation.
1. Add the standard credit transfer information.
1. Include the `beneficiaryVerificationToken` from your pre-verification.
1. Add the consent URL to the success payload.

### Mutation {#single-mutation}

🔎 [Open the mutation in API Explorer](https://explorer.swan.io?query=bXV0YXRpb24gU2luZ2xlV2l0aFRva2VuIHsKICBpbml0aWF0ZUNyZWRpdFRyYW5zZmVycygKICAgIGlucHV0OiB7CiAgICAgIGNvbnNlbnRSZWRpcmVjdFVybDogIiRZT1VSX1JFRElSRUNUX1VSTCIKICAgICAgYWNjb3VudElkOiAiJFlPVVJfQUNDT1VOVF9JRCIKICAgICAgY3JlZGl0VHJhbnNmZXJzOiB7CiAgICAgICAgYW1vdW50OiB7IHZhbHVlOiAiMTAwIiwgY3VycmVuY3k6ICJFVVIiIH0KICAgICAgICBzZXBhQmVuZWZpY2lhcnk6IHsKICAgICAgICAgIGliYW46ICJGUjc2MzAwMDYwMDAwMTEyMzQ1Njc4OTAxODkiCiAgICAgICAgICBuYW1lOiAiTWFyaWUgRHVib2lzIgogICAgICAgICAgaXNNeU93bkliYW46IGZhbHNlCiAgICAgICAgICBzYXZlOiBmYWxzZQogICAgICAgIH0KICAgICAgICBiZW5lZmljaWFyeVZlcmlmaWNhdGlvblRva2VuOiAiJFZFUklGSUNBVElPTl9UT0tFTiIKICAgICAgICBtb2RlOiBSZWd1bGFyCiAgICAgICAgcmVmZXJlbmNlOiAiSW52b2ljZSBwYXltZW50IgogICAgICB9CiAgICB9CiAgKSB7CiAgICAuLi4gb24gSW5pdGlhdGVDcmVkaXRUcmFuc2ZlcnNTdWNjZXNzUGF5bG9hZCB7CiAgICAgIF9fdHlwZW5hbWUKICAgICAgcGF5bWVudCB7CiAgICAgICAgaWQKICAgICAgICBzdGF0dXNJbmZvIHsKICAgICAgICAgIC4uLiBvbiBQYXltZW50Q29uc2VudFBlbmRpbmcgewogICAgICAgICAgICBjb25zZW50IHsKICAgICAgICAgICAgICBjb25zZW50VXJsCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC4uLiBvbiBCZW5lZmljaWFyeVZlcmlmaWNhdGlvblRva2VuQWxyZWFkeUNvbnN1bWVkUmVqZWN0aW9uIHsKICAgICAgdG9rZW4KICAgICAgbWVzc2FnZQogICAgfQogIH0KfQo%3D&tab=api)

```graphql {12,15} showLineNumbers
mutation SingleWithToken {
  initiateCreditTransfers(
    input: {
      consentRedirectUrl: "$YOUR_REDIRECT_URL"
      accountId: "$YOUR_ACCOUNT_ID"
      creditTransfers: {
        amount: { value: "100", currency: "EUR" }
        sepaBeneficiary: {
          iban: "FR7630006000011234567890189"
          name: "Marie Dubois"
          isMyOwnIban: false
          save: false
        }
        beneficiaryVerificationToken: "$VERIFICATION_TOKEN"
        mode: Regular
        reference: "Invoice payment"
      }
    }
  ) {
    ... on InitiateCreditTransfersSuccessPayload {
      __typename
      payment {
        id
        statusInfo {
          ... on PaymentConsentPending {
            consent {
              consentUrl
            }
          }
        }
      }
    }
    ... on BeneficiaryVerificationTokenAlreadyConsumedRejection {
      token
      message
    }
  }
}
```

### Success payload {#single-success}

When using a verification token, the response includes the payment with consent details:

```json {8,11} showLineNumbers
{
  "data": {
    "initiateCreditTransfers": {
      "__typename": "InitiateCreditTransfersSuccessPayload",
      "payment": {
        "id": "payment_01234567890abcdef",
        "statusInfo": {
          "__typename": "PaymentConsentPending",
          "consent": {
            "consentUrl": "https://identity.swan.io/consent?consentId=consent_123&env=Sandbox"
          }
        }
      }
    }
  }
}
```

## Bulk transfers with verification tokens {#bulk-transfers}

For multiple transfers in a single API call, include verification tokens for optimal performance.

1. Pre-verify all beneficiaries using `verifySepaBeneficiary`.
1. Call the `initiateCreditTransfers` mutation with multiple transfers.
1. Include a `beneficiaryVerificationToken` for each transfer.

### Mutation {#bulk-mutation}

🔎 [Open the mutation in API Explorer](https://explorer.swan.io?query=bXV0YXRpb24gQnVsa1dpdGhUb2tlbnMgewogIGluaXRpYXRlQ3JlZGl0VHJhbnNmZXJzKAogICAgaW5wdXQ6IHsKICAgICAgY29uc2VudFJlZGlyZWN0VXJsOiAiJFlPVVJfUkVESVJFQ1RfVVJMIgogICAgICBhY2NvdW50SWQ6ICIkWU9VUl9BQ0NPVU5UX0lEIgogICAgICBjcmVkaXRUcmFuc2ZlcnM6IFsKICAgICAgICB7CiAgICAgICAgICBhbW91bnQ6IHsgdmFsdWU6ICIyMDAiLCBjdXJyZW5jeTogIkVVUiIgfQogICAgICAgICAgc2VwYUJlbmVmaWNpYXJ5OiB7CiAgICAgICAgICAgIGliYW46ICJGUjc2MzAwMDYwMDAwMTEyMzQ1Njc4OTAxODkiCiAgICAgICAgICAgIG5hbWU6ICJNYXJpZSBEdWJvaXMiCiAgICAgICAgICAgIGlzTXlPd25JYmFuOiBmYWxzZQogICAgICAgICAgICBzYXZlOiBmYWxzZQogICAgICAgICAgfQogICAgICAgICAgYmVuZWZpY2lhcnlWZXJpZmljYXRpb25Ub2tlbjogIiRUT0tFTl8xIgogICAgICAgICAgbW9kZTogSW5zdGFudFdpdGhGYWxsYmFjawogICAgICAgICAgcmVmZXJlbmNlOiAiU3VwcGxpZXIgcGF5bWVudCAxIgogICAgICAgIH0KICAgICAgICB7CiAgICAgICAgICBhbW91bnQ6IHsgdmFsdWU6ICIxNTAiLCBjdXJyZW5jeTogIkVVUiIgfQogICAgICAgICAgc2VwYUJlbmVmaWNpYXJ5OiB7CiAgICAgICAgICAgIGliYW46ICJERTg5MzcwNDAwNDQwNTMyMDEzMDAwIgogICAgICAgICAgICBuYW1lOiAiVGVjaENvcnAgR21iSCIKICAgICAgICAgICAgaXNNeU93bkliYW46IGZhbHNlCiAgICAgICAgICAgIHNhdmU6IGZhbHNlCiAgICAgICAgICB9CiAgICAgICAgICBiZW5lZmljaWFyeVZlcmlmaWNhdGlvblRva2VuOiAiJFRPS0VOXzIiCiAgICAgICAgICBtb2RlOiBSZWd1bGFyCiAgICAgICAgICByZWZlcmVuY2U6ICJTdXBwbGllciBwYXltZW50IDIiCiAgICAgICAgfQogICAgICBdCiAgICB9CiAgKSB7CiAgICAuLi4gb24gSW5pdGlhdGVDcmVkaXRUcmFuc2ZlcnNTdWNjZXNzUGF5bG9hZCB7CiAgICAgIHBheW1lbnQgewogICAgICAgIGlkCiAgICAgICAgc3RhdHVzSW5mbyB7CiAgICAgICAgICAuLi4gb24gUGF5bWVudENvbnNlbnRQZW5kaW5nIHsKICAgICAgICAgICAgY29uc2VudCB7CiAgICAgICAgICAgICAgY29uc2VudFVybAogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQp9&tab=api)

```graphql {6,15,26} showLineNumbers
mutation BulkWithTokens {
  initiateCreditTransfers(
    input: {
      consentRedirectUrl: "$YOUR_REDIRECT_URL"
      accountId: "$YOUR_ACCOUNT_ID"
      creditTransfers: [
        {
          amount: { value: "200", currency: "EUR" }
          sepaBeneficiary: {
            iban: "FR7630006000011234567890189"
            name: "Marie Dubois"
            isMyOwnIban: false
            save: false
          }
          beneficiaryVerificationToken: "$TOKEN_1"
          mode: InstantWithFallback
          reference: "Supplier payment 1"
        }
        {
          amount: { value: "150", currency: "EUR" }
          sepaBeneficiary: {
            iban: "DE89370400440532013000"
            name: "TechCorp GmbH"
            isMyOwnIban: false
            save: false
          }
          beneficiaryVerificationToken: "$TOKEN_2"
          mode: Regular
          reference: "Supplier payment 2"
        }
      ]
    }
  ) {
    ... on InitiateCreditTransfersSuccessPayload {
      payment {
        id
        statusInfo {
          ... on PaymentConsentPending {
            consent {
              consentUrl
            }
          }
        }
      }
    }
  }
}
```

## Automatic VoP fallback {#automatic-fallback}

If you don't include verification tokens, Swan automatically runs VoP for single transfers:

```graphql title="Single transfer without token (automatic VoP)" showLineNumbers
mutation AutomaticVoP {
  initiateCreditTransfers(
    input: {
      accountId: "$YOUR_ACCOUNT_ID"
      consentRedirectUrl: "$YOUR_REDIRECT_URL"
      creditTransfers: {
        amount: { value: "100", currency: "EUR" }
        sepaBeneficiary: {
          iban: "FR7630006000011234567890189"
          name: "Marie Dubois"
          isMyOwnIban: false
          save: false
        }
        mode: Regular
        reference: "Invoice payment"
      }
    }
  ) {
    ... on InitiateCreditTransfersSuccessPayload {
      payment {
        id
        statusInfo {
          ... on PaymentConsentPending {
            consent {
              consentUrl
            }
          }
        }
      }
    }
  }
}
```

Swan runs VoP in the background and displays results in the consent screen.

:::info Performance
Using verification tokens provides faster processing since VoP has already been completed. For bulk transfers or repeated beneficiaries, pre-verification significantly improves user experience.
:::

## Error handling {#error-handling}

### Token already consumed {#error-consumed}

Verification tokens are single-use:

```json showLineNumbers
{
  "data": {
    "initiateCreditTransfers": {
      "__typename": "BeneficiaryVerificationTokenAlreadyConsumedRejection",
      "token": "vt_abc123...",
      "message": "This verification token has already been used"
    }
  }
}
```

**Solution**: Generate a new verification with `verifySepaBeneficiary`.

### Verification timeout {#error-timeout}

If VoP times out during automatic verification (without token):

```json showLineNumbers
{
  "result": {
    "__typename": "BeneficiaryVerificationNotPossible",
    "reason": "Technical timeout - verification service unavailable"
  }
}
```

**Solution**: The transfer can still proceed. Users will see a warning in the consent screen.

### Invalid token format {#error-invalid-token}

Malformed or expired tokens:

```json showLineNumbers
{
  "data": {
    "initiateCreditTransfers": {
      "__typename": "ValidationRejection",
      "message": "Invalid verification token format"
    }
  }
}
```

**Solution**: Ensure tokens are properly stored and not expired (24-hour limit).

## VoP in consent screen {#consent-display}

Swan automatically displays VoP results in the consent screen with clear user guidance:

### Match result ✅ {#consent-match}
- **Display**: Green checkmark with "Beneficiary verified"
- **User action**: Can proceed with confidence
- **Payment flow**: No additional warnings

### Close Match result ⚠️ {#consent-close-match}
- **Display**: Warning icon with suggested name correction
- **Example**: "Did you mean 'John Smith' instead of 'Jon Smith'?"
- **User action**: Can proceed or go back to correct name
- **Payment flow**: Proceeds with warning if user confirms

### No Match result ❌ {#consent-no-match}
- **Display**: Warning about potential misdirected payment
- **Message**: "Name doesn't match bank records. Double-check beneficiary details."
- **User action**: Strongly advised to verify beneficiary details
- **Payment flow**: Proceeds with explicit warning if user confirms

### Verification Not Possible ⚠️ {#consent-not-possible}
- **Display**: Notice that verification couldn't be completed
- **Message**: "Verification unavailable due to technical issues. You can still proceed."
- **User action**: Can proceed with additional caution
- **Payment flow**: Proceeds with notice about unverified payment

## Integration patterns {#integration-patterns}

### Pre-verification workflow {#pattern-pre-verification}

Recommended flow for adding beneficiaries:

```typescript
// Pseudo-code for beneficiary management
async function addBeneficiary(iban: string, name: string) {
  try {
    // 1. Verify beneficiary first
    const verification = await verifySepaBeneficiary({
      accountId: currentAccount.id,
      payees: [{ iban, name, externalReference: `beneficiary-${Date.now()}` }]
    });

    const result = verification.verifications[0];
    
    // 2. Handle verification result
    if (result.result.__typename === "BeneficiaryCloseMatch") {
      // Show suggested name to user
      const shouldUpdate = await showNameSuggestion(
        result.result.suggestedName,
        result.result.providedName
      );
      if (shouldUpdate) {
        name = result.result.suggestedName;
      }
    } else if (result.result.__typename === "BeneficiaryMismatch") {
      // Warn user about potential issues
      const shouldContinue = await confirmMismatch(result.result.providedName);
      if (!shouldContinue) return null;
    } else if (result.result.__typename === "BeneficiaryVerificationNotPossible") {
      // Technical issue - allow user to proceed with warning
      await showTechnicalWarning(result.result.reason);
    }

    // 3. Save beneficiary with verification token
    const beneficiary = await saveBeneficiary({
      iban,
      name,
      verificationToken: result.token,
      tokenCreatedAt: new Date(),
      verificationResult: result.result.__typename
    });

    return beneficiary;
  } catch (error) {
    console.error('Verification failed:', error);
    // Allow saving without verification as fallback
    return await saveBeneficiary({ iban, name });
  }
}
```

### Payment initiation workflow {#pattern-payment}

Using pre-verified beneficiaries for payments:

```typescript
// Pseudo-code for payment initiation
async function initiatePayment(beneficiary: Beneficiary, amount: string, reference?: string) {
  // Check if we have a valid verification token
  if (beneficiary.verificationToken && isTokenValid(beneficiary)) {
    // Use existing token for faster processing
    return await initiateCreditTransfers({
      accountId: currentAccount.id,
      consentRedirectUrl: REDIRECT_URL,
      creditTransfers: {
        amount: { value: amount, currency: "EUR" },
        sepaBeneficiary: {
          iban: beneficiary.iban,
          name: beneficiary.name,
          isMyOwnIban: false,
          save: false
        },
        beneficiaryVerificationToken: beneficiary.verificationToken,
        mode: "Regular",
        reference: reference || `Payment to ${beneficiary.name}`
      }
    });
  } else {
    // Token expired or missing - automatic VoP will run
    console.log('Token expired or missing, using automatic VoP');
    return await initiateCreditTransfers({
      accountId: currentAccount.id,
      consentRedirectUrl: REDIRECT_URL,
      creditTransfers: {
        amount: { value: amount, currency: "EUR" },
        sepaBeneficiary: {
          iban: beneficiary.iban,
          name: beneficiary.name,
          isMyOwnIban: false,
          save: false
        },
        mode: "Regular",
        reference: reference || `Payment to ${beneficiary.name}`
      }
    });
  }
}

function isTokenValid(beneficiary: Beneficiary): boolean {
  if (!beneficiary.verificationToken || !beneficiary.tokenCreatedAt) {
    return false;
  }
  
  const now = new Date();
  const expiry = new Date(beneficiary.tokenCreatedAt.getTime() + 24 * 60 * 60 * 1000);
  return now < expiry;
}
```

### Bulk payment workflow {#pattern-bulk}

Processing multiple payments efficiently:

```typescript
async function initiateBulkPayments(payments: PaymentRequest[]) {
  // 1. Verify all beneficiaries that don't have valid tokens
  const toVerify = payments.filter(p => !isTokenValid(p.beneficiary));
  
  if (toVerify.length > 0) {
    const verification = await verifySepaBeneficiary({
      accountId: currentAccount.id,
      payees: toVerify.map((p, index) => ({
        iban: p.beneficiary.iban,
        name: p.beneficiary.name,
        externalReference: `bulk-${Date.now()}-${index}`
      }))
    });

    // Update beneficiaries with new tokens
    verification.verifications.forEach((result, index) => {
      toVerify[index].beneficiary.verificationToken = result.token;
      toVerify[index].beneficiary.tokenCreatedAt = new Date();
    });
  }

  // 2. Initiate bulk transfer with all tokens
  return await initiateCreditTransfers({
    accountId: currentAccount.id,
    consentRedirectUrl: REDIRECT_URL,
    creditTransfers: payments.map(p => ({
      amount: { value: p.amount, currency: "EUR" },
      sepaBeneficiary: {
        iban: p.beneficiary.iban,
        name: p.beneficiary.name,
        isMyOwnIban: false,
        save: false
      },
      beneficiaryVerificationToken: p.beneficiary.verificationToken,
      mode: p.mode || "Regular",
      reference: p.reference
    }))
  });
}
```

## Token lifecycle management {#token-lifecycle}

### Token validation {#token-validation}

```typescript
interface VerificationToken {
  value: string;
  createdAt: Date;
  consumed: boolean;
  beneficiaryIban: string;
  beneficiaryName: string;
}

class TokenManager {
  static isValid(token: VerificationToken): boolean {
    if (token.consumed) return false;
    
    const now = new Date();
    const expiry = new Date(token.createdAt.getTime() + 24 * 60 * 60 * 1000);
    return now < expiry;
  }

  static timeUntilExpiry(token: VerificationToken): number {
    const now = new Date();
    const expiry = new Date(token.createdAt.getTime() + 24 * 60 * 60 * 1000);
    return Math.max(0, expiry.getTime() - now.getTime());
  }

  static markAsConsumed(token: VerificationToken): void {
    token.consumed = true;
  }

  static shouldRefresh(token: VerificationToken): boolean {
    const timeLeft = this.timeUntilExpiry(token);
    const oneHour = 60 * 60 * 1000;
    return timeLeft < oneHour; // Refresh if less than 1 hour left
  }
}
```

### Cleanup and maintenance {#token-cleanup}

```typescript
// Clean up expired tokens periodically
async function cleanupExpiredTokens() {
  const expiredTokens = await getTokensOlderThan(24 * 60 * 60 * 1000);
  await deleteTokens(expiredTokens.map(t => t.id));
  console.log(`Cleaned up ${expiredTokens.length} expired tokens`);
}

// Run cleanup daily
setInterval(cleanupExpiredTokens, 24 * 60 * 60 * 1000);
```

## Best practices {#best-practices}

### Performance optimization

1. **Pre-verify for better UX** - Use `verifySepaBeneficiary` for faster processing
2. **Batch verifications** - Verify multiple beneficiaries in single API calls
3. **Cache tokens effectively** - Store tokens with expiration tracking
4. **Implement token refresh** - Re-verify before tokens expire

### Error recovery strategies

1. **Graceful degradation** - Fall back to automatic VoP when tokens fail
2. **Retry logic** - Implement exponential backoff for network failures
3. **User communication** - Provide clear feedback for all VoP result types
4. **Token rotation** - Refresh tokens proactively before expiration

### Security considerations

1. **Secure token storage** - Encrypt tokens at rest
2. **Access control** - Limit token access to authorized users
3. **Audit logging** - Log token usage and verification results
4. **Data protection** - Follow GDPR requirements for beneficiary data

### User experience guidelines

**Clear messaging for VoP results:**
```typescript
const VOP_MESSAGES = {
  'BeneficiaryMatch': {
    icon: '✅',
    title: 'Beneficiary Verified',
    message: 'Name matches bank records',
    action: 'proceed'
  },
  'BeneficiaryCloseMatch': {
    icon: '⚠️',
    title: 'Name Suggestion',
    message: (suggested: string) => `Did you mean "${suggested}"?`,
    action: 'suggest'
  },
  'BeneficiaryMismatch': {
    icon: '❌',
    title: 'Name Mismatch',
    message: 'Name doesn\'t match bank records. Double-check details.',
    action: 'warn'
  },
  'BeneficiaryVerificationNotPossible': {
    icon: '⚠️',
    title: 'Verification Unavailable',
    message: 'Verification service temporarily unavailable',
    action: 'notice'
  }
};
```

**Progressive enhancement:**
- Start with basic VoP integration (automatic for single transfers)
- Add pre-verification for improved UX
- Implement bulk optimization with tokens
- Add advanced features like proactive token refresh

### Implementation timeline

**Week 1-2: Basic Integration**
```typescript
// Step 1: Add automatic VoP support
function initiateSingleTransfer(beneficiary: Beneficiary, amount: string) {
  return initiateCreditTransfers({
    creditTransfers: {
      amount: { value: amount, currency: "EUR" },
      sepaBeneficiary: beneficiary,
      mode: "Regular"
    }
  });
}
```

**Week 3-4: Pre-verification**
```typescript
// Step 2: Add pre-verification for better UX
async function addVerifiedBeneficiary(iban: string, name: string) {
  const verification = await verifySepaBeneficiary({
    payees: [{ iban, name }]
  });
  
  return saveBeneficiary({
    iban,
    name,
    verificationToken: verification.verifications[0].token
  });
}
```

**Week 5-6: Bulk optimization**
```typescript
// Step 3: Optimize for bulk payments
async function initiateBulkPayments(payments: PaymentRequest[]) {
  // Pre-verify missing tokens
  // Submit bulk transfer with all tokens
}
```

**Week 7+: Advanced features**
- Token refresh strategies
- Advanced error handling
- Performance monitoring
- User experience improvements

## Related guides {#related}

- [Verify a beneficiary](./guide-verify-beneficiary.mdx) - Create verification tokens
- [VoP with standing orders](./guide-vop-standing-orders.mdx) - Standing order verification
- [Sandbox testing](./sandbox.mdx) - Test VoP scenarios
- [API Reference](./api-reference.mdx) - Complete GraphQL documentation
- [Initiate a credit transfer](../sepa/guide-initiate-ct.mdx) - Standard credit transfer flow